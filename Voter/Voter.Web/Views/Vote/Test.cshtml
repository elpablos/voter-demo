@model Voter.Web.Controllers.Vote.List.ListVoteModel
@{
    ViewBag.Title = "Přehled";
}

<div class="app-title">
    <div>
        <h1><i class="fa fa-money"></i> Detail záznamu</h1>
        <p>Všechny podrobnosti o daném záznamu</p>
    </div>
    <ul class="app-breadcrumb breadcrumb">
        <li class="breadcrumb-item"><a href="@Url.Action("Index", "Home")"><i class="fa fa-home fa-lg"></i></a></li>
        <li class="breadcrumb-item">@Html.ActionLink("Přehled", "Index")</li>
        @*<li class="breadcrumb-item"><a href="@Url.Action()">Detail záznamu</a></li>*@
    </ul>
</div>

<div class="row">
    <div class="col-md-12">

        <ul class="nav nav-tabs">
            @if (Html.HasAction("VT_Question_DETAIL"))
            {
                <li class="nav-item">
                    @Html.ActionLink("Detail", "Detail", new { id = Url.RequestContext.RouteData.Values["id"] }, htmlAttributes: new { @class = "nav-link active" })
                </li>
            }
            @if (Html.HasAction("CR_EntityLog_ALL_Question_VT"))
            {
                <li class="nav-item">
                    @Html.ActionLink("Historie", "History", new { id = Url.RequestContext.RouteData.Values["id"] }, htmlAttributes: new { @class = "nav-link" })
                </li>
            }
        </ul>

        <div class="tile">
            <div class="tile-title line-head">
                <h3>Snake</h3>
            </div>
            <div class="tile-body">
                <div class="row">
                    <div id="phaser-example"></div>
                </div>
            </div>

            <div class="tile-footer">
            </div>
        </div>
    </div>
</div>

@section scripts {

    <!--Script references. -->
    <!--Reference the jQuery library. -->
    @*<script src="Scripts/jquery-3.2.1.min.js"></script>*@
    <!--Reference the SignalR library. -->
    <script src="/Scripts/jquery.signalR-2.4.1.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.17.0/dist/phaser.min.js"></script>
    <!--Reference the autogenerated SignalR hub script. -->
    <script src="/signalr/hubs"></script>
    <!--Add script to update the page and send messages.-->
    <script type="text/javascript">

        $(function () {
            // Declare a proxy to reference the hub.
            var chat = $.connection.voterHub;
            // Create a function that the hub can call to broadcast messages.
            chat.client.broadcastMessage = function (name, message) {
                // Html encode display name and message.
                //var encodedName = $('<div />').text(name).html();
                //var encodedMsg = $('<div />').text(message).html();
                //// Add the message to the page.
                //$('#discussion').append('<li><strong>' + encodedName
                //    + '</strong>:&nbsp;&nbsp;' + encodedMsg + '</li>');

                if (message == "Yes") {
                    snake.faceLeft();
                } else if (message == "No") {
                    snake.faceRight();
                }
            };
            //// Get the user name and store it to prepend to messages.
            //$('#displayname').val(prompt('Enter your name:', ''));
            //// Set initial focus to message input box.
            //$('#message').focus();
            //// Start the connection.
            $.connection.hub.start().done(function () {
                //$('#sendmessage').click(function () {
                //    // Call the Send method on the hub.
                //    chat.server.send($('#displayname').val(), $('#message').val());
                //    // Clear text box and reset focus for next comment.
                //    $('#message').val('').focus();
                //});
            });
        });
    </script>

    <script>
        var config = {
            type: Phaser.WEBGL,
            width: 640,
            height: 480,
            backgroundColor: '#bfcc00',
            parent: 'phaser-example',
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        var snake;
        var food;

        //  Direction consts
        var UP = 0;
        var DOWN = 1;
        var LEFT = 2;
        var RIGHT = 3;

        var game = new Phaser.Game(config);

        function preload() {
            this.load.image('food', '../Images/snake/food.png');
            this.load.image('body', '../Images/snake/body.png');
        }

        function create() {
            var Food = new Phaser.Class({

                Extends: Phaser.GameObjects.Image,

                initialize:

                    function Food(scene, x, y) {
                        Phaser.GameObjects.Image.call(this, scene)

                        this.setTexture('food');
                        this.setPosition(x * 16, y * 16);
                        this.setOrigin(0);

                        this.total = 0;

                        scene.children.add(this);
                    },

                eat: function () {
                    this.total++;
                }

            });

            var Snake = new Phaser.Class({

                initialize:

                    function Snake(scene, x, y) {
                        this.headPosition = new Phaser.Geom.Point(x, y);

                        this.body = scene.add.group();

                        this.head = this.body.create(x * 16, y * 16, 'body');
                        this.head.setOrigin(0);

                        this.alive = true;

                        this.speed = 100;

                        this.moveTime = 0;

                        this.tail = new Phaser.Geom.Point(x, y);

                        this.heading = RIGHT;
                        this.direction = RIGHT;
                    },

                update: function (time) {
                    if (time >= this.moveTime) {
                        return this.move(time);
                    }
                },

                faceLeft: function () {

                    if (this.direction === UP) {
                        this.heading = LEFT;
                    } else if (this.direction === LEFT) {
                        this.heading = DOWN;
                    } else if (this.direction === DOWN) {
                        this.heading = RIGHT;
                    } else if (this.direction === RIGHT) {
                        this.heading = UP;
                    }
                },

                faceRight: function () {

                    if (this.direction === UP) {
                        this.heading = RIGHT;
                    } else if (this.direction === RIGHT) {
                        this.heading = DOWN;
                    } else if (this.direction === DOWN) {
                        this.heading = LEFT;
                    } else if (this.direction === LEFT) {
                        this.heading = UP;
                    }

                },

                move: function (time) {
                    /**
                    * Based on the heading property (which is the direction the pgroup pressed)
                    * we update the headPosition value accordingly.
                    *
                    * The Math.wrap call allow the snake to wrap around the screen, so when
                    * it goes off any of the sides it re-appears on the other.
                    */
                    switch (this.heading) {
                        case LEFT:
                            this.headPosition.x = Phaser.Math.Wrap(this.headPosition.x - 1, 0, 40);
                            break;

                        case RIGHT:
                            this.headPosition.x = Phaser.Math.Wrap(this.headPosition.x + 1, 0, 40);
                            break;

                        case UP:
                            this.headPosition.y = Phaser.Math.Wrap(this.headPosition.y - 1, 0, 30);
                            break;

                        case DOWN:
                            this.headPosition.y = Phaser.Math.Wrap(this.headPosition.y + 1, 0, 30);
                            break;
                    }

                    this.direction = this.heading;

                    //  Update the body segments and place the last coordinate into this.tail
                    Phaser.Actions.ShiftPosition(this.body.getChildren(), this.headPosition.x * 16, this.headPosition.y * 16, 1, this.tail);

                    //  Check to see if any of the body pieces have the same x/y as the head
                    //  If they do, the head ran into the body

                    var hitBody = Phaser.Actions.GetFirst(this.body.getChildren(), { x: this.head.x, y: this.head.y }, 1);

                    if (hitBody) {
                        console.log('dead');

                        this.alive = false;

                        return false;
                    }
                    else {
                        //  Update the timer ready for the next movement
                        this.moveTime = time + this.speed;

                        return true;
                    }
                },

                grow: function () {
                    var newPart = this.body.create(this.tail.x, this.tail.y, 'body');

                    newPart.setOrigin(0);
                },

                collideWithFood: function (food) {
                    if (this.head.x === food.x && this.head.y === food.y) {
                        this.grow();

                        food.eat();

                        //  For every 5 items of food eaten we'll increase the snake speed a little
                        if (this.speed > 20 && food.total % 5 === 0) {
                            this.speed -= 5;
                        }

                        return true;
                    }
                    else {
                        return false;
                    }
                },

                updateGrid: function (grid) {
                    //  Remove all body pieces from valid positions list
                    this.body.children.each(function (segment) {

                        var bx = segment.x / 16;
                        var by = segment.y / 16;

                        grid[by][bx] = false;

                    });

                    return grid;
                }

            });

            food = new Food(this, 3, 4);

            snake = new Snake(this, 8, 8);
        }

        function update(time, delta) {
            if (!snake.alive) {
                return;
            }

            /**
            * Check which key is pressed, and then change the direction the snake
            * is heading based on that. The checks ensure you don't double-back
            * on yourself, for example if you're moving to the right and you press
            * the LEFT cursor, it ignores it, because the only valid directions you
            * can move in at that time is up and down.
            */


            if (snake.update(time)) {
                //  If the snake updated, we need to check for collision against food

                if (snake.collideWithFood(food)) {
                    repositionFood();
                }
            }
        }

        /**
        * We can place the food anywhere in our 40x30 grid
        * *except* on-top of the snake, so we need
        * to filter those out of the possible food locations.
        * If there aren't any locations left, they've won!
        */
        function repositionFood() {
            //  First create an array that assumes all positions
            //  are valid for the new piece of food

            //  A Grid we'll use to reposition the food each time it's eaten
            var testGrid = [];

            for (var y = 0; y < 30; y++) {
                testGrid[y] = [];

                for (var x = 0; x < 40; x++) {
                    testGrid[y][x] = true;
                }
            }

            snake.updateGrid(testGrid);

            //  Purge out false positions
            var validLocations = [];

            for (var y = 0; y < 30; y++) {
                for (var x = 0; x < 40; x++) {
                    if (testGrid[y][x] === true) {
                        //  Is this position valid for food? If so, add it here ...
                        validLocations.push({ x: x, y: y });
                    }
                }
            }

            if (validLocations.length > 0) {
                //  Use the RNG to pick a random food position
                var pos = Phaser.Math.RND.pick(validLocations);

                //  And place it
                food.setPosition(pos.x * 16, pos.y * 16);

                return true;
            }
            else {
                return false;
            }
        }

    </script>
}
